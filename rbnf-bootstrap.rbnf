# lexer definition
auto_const := '::=' ':=' '<<' '->' '=>'
auto_const := '=' '<' '>' '/' '|' '{' '}' '[' ']' '(' ')' '+' '*' '.' ',' ';' '?'
Str        := R'[A-Z]\'([^\\\']+|\\.)*?\'|\'([^\\\']+|\\.)*?\''
Name       := R'[a-zA-Z_\u4e00-\u9fa5][a-zA-Z0-9_\u4e00-\u9fa5]*'
Int        := R'\d+'
Space      := R'\s+'
Comment    := R'(#.*)|(((/\*)+?[\w\W]+?(\*/)+))'
kword cast := 'rewrite' 'when' 'import' 'extern' 'constvalue' 'recur'

# helper parser definition
ignore [Comment Space]

CodeItem   ::= _=_
    when
        state.ctx['begin_sign'].colno < tokens[state.end_index].colno
    -> _


# syntax node parser definition
Lexer      ::=
    [is_const='constvalue'] name=Name ':=' lexers=(Str+ | 'extern') ';'
    -> LexerC(name, lexers, bool(is_const))

Parser    ::=
    [is_recur='recur'] name=Name '::='
    ['|']
    impl=ADTParser
    ';'
    -> ParserC(name, impl, clauses, bool(is_recur))

ADTParser ::=
    | cases<<Case
      ('|' cases<<Case)*
    | single=AndParser
    -> single or ADTParserC(cases)

Case ::=
    name=Name impl=AndParser
    -> CaseC(name, impl)

OrParser ::=
    brs<<AndParser ('|' brs<<AndParser)*
    -> OrParser(brs) if len(brs) is not 1 else brs[0]

AndParser ::=
    (exprs<<ClauseExpr)+
    -> AndParser(exprs) if len(exprs) is not 1 else exprs[0]

ClauseExpr::=
    [bind_name=Name (bind='=' | push='<<')]
    expr=Expr ['{' rep=(Int{1 2}) '}'
              | star='*'
              | plus='+'
              | '=>' rew=Name]
    ->
        if rep:
            expr = RepC(rep, expr)
        elif star:
            expr = StarC(expr)
        elif plus:
            expr = PlusC(expr)
        elif rew:
            expr = RewriteC(rew, expr)
        if bind_name:
            expr = (BindC if bind else PushC)(bind_name, expr)
        return expr

Expr ::=
    | '(' nested=OrParser ')'
    | '[' optional=OrParser ']'
    | '?' predicate=Name
    | ref=Name
    | literal=Str
    ->
        if nested:
            return nested
        if predicate:
            return PredicateC(predicate)
        if optional:
            return OptionalC(optional)
        if ref:
            return RefC(ref)
        if literal:
            return LiteralC(literal)


Module ::= (';' | suites <<(Lexer | Parser))+ -> ModuleC(suites);

